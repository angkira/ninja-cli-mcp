{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# üí∞ Deep Cost Analysis\n",
    "\n",
    "Detailed cost breakdown and projections for different models.\n",
    "\n",
    "**Analysis includes:**\n",
    "- Real-time pricing from OpenRouter API\n",
    "- Cost per 1M tokens\n",
    "- Cache token savings (prompt caching)\n",
    "- Projected costs for typical workloads"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import sys\n",
    "from pathlib import Path\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import json\n",
    "\n",
    "# Setup\n",
    "sns.set_style(\"whitegrid\")\n",
    "plt.rcParams['figure.figsize'] = (14, 6)\n",
    "\n",
    "sys.path.insert(0, str(Path.cwd().parent / \"src\"))\n",
    "\n",
    "from ninja_cli_mcp.metrics import fetch_openrouter_pricing, get_model_pricing\n",
    "\n",
    "print(\"‚úÖ Setup complete\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## üìä Fetch Real-Time Pricing"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Target models\n",
    "MODELS = {\n",
    "    \"Qwen 2.5 Coder 32B\": \"qwen/qwen-2.5-coder-32b-instruct\",\n",
    "    \"Claude Sonnet 4\": \"anthropic/claude-sonnet-4\",\n",
    "    \"Claude Haiku 4\": \"anthropic/claude-haiku-4\",\n",
    "    \"Gemini 2.0 Flash\": \"google/gemini-2.0-flash-exp:free\",\n",
    "    \"GPT-4o\": \"openai/gpt-4o\",\n",
    "    \"DeepSeek Coder\": \"deepseek/deepseek-coder\",\n",
    "}\n",
    "\n",
    "print(\"üîÑ Fetching pricing from OpenRouter API...\")\n",
    "pricing_data = fetch_openrouter_pricing()\n",
    "print(f\"‚úÖ Fetched pricing for {len(pricing_data)} models\\n\")\n",
    "\n",
    "# Get pricing for our models\n",
    "model_pricing = {}\n",
    "for name, model_id in MODELS.items():\n",
    "    pricing = get_model_pricing(model_id)\n",
    "    model_pricing[name] = {\n",
    "        'model_id': model_id,\n",
    "        'input_per_1m': pricing['input'],\n",
    "        'output_per_1m': pricing['output'],\n",
    "        'cache_read_per_1m': pricing['cache_read'],\n",
    "        'cache_write_per_1m': pricing['cache_write'],\n",
    "    }\n",
    "\n",
    "# Display pricing table\n",
    "pricing_df = pd.DataFrame(model_pricing).T\n",
    "print(\"üíµ Current Pricing (per 1M tokens):\\n\")\n",
    "display(pricing_df.style.format({\n",
    "    'input_per_1m': '${:.2f}',\n",
    "    'output_per_1m': '${:.2f}',\n",
    "    'cache_read_per_1m': '${:.2f}',\n",
    "    'cache_write_per_1m': '${:.2f}',\n",
    "}))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## üìà Pricing Comparison Charts"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fig, axes = plt.subplots(2, 2, figsize=(16, 12))\n",
    "\n",
    "# Input tokens cost\n",
    "ax1 = axes[0, 0]\n",
    "pricing_df['input_per_1m'].sort_values().plot(kind='barh', ax=ax1, color='steelblue')\n",
    "ax1.set_title('ÔøΩÔøΩ Input Token Cost (per 1M)', fontsize=14, fontweight='bold')\n",
    "ax1.set_xlabel('Cost ($)')\n",
    "ax1.grid(axis='x', alpha=0.3)\n",
    "\n",
    "# Output tokens cost\n",
    "ax2 = axes[0, 1]\n",
    "pricing_df['output_per_1m'].sort_values().plot(kind='barh', ax=ax2, color='coral')\n",
    "ax2.set_title('üí≠ Output Token Cost (per 1M)', fontsize=14, fontweight='bold')\n",
    "ax2.set_xlabel('Cost ($)')\n",
    "ax2.grid(axis='x', alpha=0.3)\n",
    "\n",
    "# Cache read cost (if available)\n",
    "ax3 = axes[1, 0]\n",
    "cache_read = pricing_df[pricing_df['cache_read_per_1m'] > 0]['cache_read_per_1m'].sort_values()\n",
    "if not cache_read.empty:\n",
    "    cache_read.plot(kind='barh', ax=ax3, color='green')\n",
    "    ax3.set_title('üîÑ Cache Read Cost (per 1M)', fontsize=14, fontweight='bold')\n",
    "    ax3.set_xlabel('Cost ($)')\n",
    "    ax3.grid(axis='x', alpha=0.3)\n",
    "else:\n",
    "    ax3.text(0.5, 0.5, 'No cache pricing available', \n",
    "             ha='center', va='center', fontsize=12)\n",
    "    ax3.set_axis_off()\n",
    "\n",
    "# Total cost comparison (input + output)\n",
    "ax4 = axes[1, 1]\n",
    "pricing_df['total_per_1m'] = pricing_df['input_per_1m'] + pricing_df['output_per_1m']\n",
    "pricing_df['total_per_1m'].sort_values().plot(kind='barh', ax=ax4, color='purple')\n",
    "ax4.set_title('üí∏ Total Cost (Input + Output per 1M)', fontsize=14, fontweight='bold')\n",
    "ax4.set_xlabel('Cost ($)')\n",
    "ax4.grid(axis='x', alpha=0.3)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.savefig('pricing_comparison.png', dpi=150, bbox_inches='tight')\n",
    "plt.show()\n",
    "\n",
    "print(\"üì∏ Saved: pricing_comparison.png\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## üéØ Cost Projections for Typical Workloads"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define typical workload scenarios\n",
    "SCENARIOS = {\n",
    "    \"Small Task\": {\n",
    "        \"description\": \"Add docstring, fix typo\",\n",
    "        \"input_tokens\": 500,\n",
    "        \"output_tokens\": 200,\n",
    "    },\n",
    "    \"Medium Task\": {\n",
    "        \"description\": \"Add feature, refactor function\",\n",
    "        \"input_tokens\": 2000,\n",
    "        \"output_tokens\": 800,\n",
    "    },\n",
    "    \"Large Task\": {\n",
    "        \"description\": \"Complex refactoring, new module\",\n",
    "        \"input_tokens\": 10000,\n",
    "        \"output_tokens\": 3000,\n",
    "    },\n",
    "    \"Daily Usage (100 tasks)\": {\n",
    "        \"description\": \"100 small tasks per day\",\n",
    "        \"input_tokens\": 50000,\n",
    "        \"output_tokens\": 20000,\n",
    "    },\n",
    "}\n",
    "\n",
    "# Calculate costs for each scenario\n",
    "scenario_costs = []\n",
    "\n",
    "for scenario_name, scenario in SCENARIOS.items():\n",
    "    input_tokens = scenario['input_tokens']\n",
    "    output_tokens = scenario['output_tokens']\n",
    "    \n",
    "    for model_name in pricing_df.index:\n",
    "        pricing = pricing_df.loc[model_name]\n",
    "        \n",
    "        # Calculate cost\n",
    "        input_cost = (input_tokens / 1_000_000) * pricing['input_per_1m']\n",
    "        output_cost = (output_tokens / 1_000_000) * pricing['output_per_1m']\n",
    "        total_cost = input_cost + output_cost\n",
    "        \n",
    "        # With 50% cache hit (cache read is ~90% cheaper)\n",
    "        if pricing['cache_read_per_1m'] > 0:\n",
    "            cache_input_cost = (input_tokens * 0.5 / 1_000_000) * pricing['cache_read_per_1m']\n",
    "            regular_input_cost = (input_tokens * 0.5 / 1_000_000) * pricing['input_per_1m']\n",
    "            cached_total = cache_input_cost + regular_input_cost + output_cost\n",
    "            savings = total_cost - cached_total\n",
    "        else:\n",
    "            cached_total = total_cost\n",
    "            savings = 0\n",
    "        \n",
    "        scenario_costs.append({\n",
    "            'Scenario': scenario_name,\n",
    "            'Model': model_name,\n",
    "            'Cost (no cache)': total_cost,\n",
    "            'Cost (with cache)': cached_total,\n",
    "            'Savings': savings,\n",
    "            'Savings %': (savings / total_cost * 100) if total_cost > 0 else 0,\n",
    "        })\n",
    "\n",
    "scenario_df = pd.DataFrame(scenario_costs)\n",
    "\n",
    "# Display cost projections\n",
    "for scenario_name in SCENARIOS.keys():\n",
    "    print(f\"\\n{'='*70}\")\n",
    "    print(f\"üìã {scenario_name}: {SCENARIOS[scenario_name]['description']}\")\n",
    "    print(f\"{'='*70}\")\n",
    "    \n",
    "    scenario_data = scenario_df[scenario_df['Scenario'] == scenario_name].set_index('Model')\n",
    "    scenario_data = scenario_data.sort_values('Cost (no cache)')\n",
    "    \n",
    "    display(scenario_data[['Cost (no cache)', 'Cost (with cache)', 'Savings', 'Savings %']].style.format({\n",
    "        'Cost (no cache)': '${:.6f}',\n",
    "        'Cost (with cache)': '${:.6f}',\n",
    "        'Savings': '${:.6f}',\n",
    "        'Savings %': '{:.1f}%',\n",
    "    }).background_gradient(subset=['Cost (no cache)'], cmap='RdYlGn_r'))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## üìä Monthly Cost Projections"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Monthly projections (assuming daily usage scenario)\n",
    "daily_scenario = scenario_df[scenario_df['Scenario'] == 'Daily Usage (100 tasks)'].copy()\n",
    "daily_scenario['Monthly Cost (no cache)'] = daily_scenario['Cost (no cache)'] * 30\n",
    "daily_scenario['Monthly Cost (with cache)'] = daily_scenario['Cost (with cache)'] * 30\n",
    "daily_scenario['Monthly Savings'] = daily_scenario['Savings'] * 30\n",
    "\n",
    "monthly_df = daily_scenario[['Model', 'Monthly Cost (no cache)', 'Monthly Cost (with cache)', 'Monthly Savings']].set_index('Model')\n",
    "monthly_df = monthly_df.sort_values('Monthly Cost (no cache)')\n",
    "\n",
    "print(\"\\nüìÖ Monthly Cost Projections (100 tasks/day):\\n\")\n",
    "display(monthly_df.style.format({\n",
    "    'Monthly Cost (no cache)': '${:.2f}',\n",
    "    'Monthly Cost (with cache)': '${:.2f}',\n",
    "    'Monthly Savings': '${:.2f}',\n",
    "}).background_gradient(subset=['Monthly Cost (no cache)'], cmap='RdYlGn_r'))\n",
    "\n",
    "# Visualize monthly costs\n",
    "fig, ax = plt.subplots(figsize=(12, 6))\n",
    "\n",
    "x = range(len(monthly_df))\n",
    "width = 0.35\n",
    "\n",
    "bars1 = ax.bar([i - width/2 for i in x], monthly_df['Monthly Cost (no cache)'], \n",
    "               width, label='No Cache', color='coral', alpha=0.8)\n",
    "bars2 = ax.bar([i + width/2 for i in x], monthly_df['Monthly Cost (with cache)'], \n",
    "               width, label='With Cache', color='green', alpha=0.8)\n",
    "\n",
    "ax.set_xlabel('Model', fontsize=12)\n",
    "ax.set_ylabel('Monthly Cost ($)', fontsize=12)\n",
    "ax.set_title('üí≥ Monthly Cost Comparison (100 tasks/day)', fontsize=14, fontweight='bold')\n",
    "ax.set_xticks(x)\n",
    "ax.set_xticklabels(monthly_df.index, rotation=45, ha='right')\n",
    "ax.legend()\n",
    "ax.grid(axis='y', alpha=0.3)\n",
    "\n",
    "# Add value labels on bars\n",
    "for bars in [bars1, bars2]:\n",
    "    for bar in bars:\n",
    "        height = bar.get_height()\n",
    "        ax.text(bar.get_x() + bar.get_width()/2., height,\n",
    "                f'${height:.2f}',\n",
    "                ha='center', va='bottom', fontsize=8)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.savefig('monthly_costs.png', dpi=150, bbox_inches='tight')\n",
    "plt.show()\n",
    "\n",
    "print(\"\\nüì∏ Saved: monthly_costs.png\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## üí° Cache Savings Analysis"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Calculate cache savings for models that support it\n",
    "cache_models = pricing_df[pricing_df['cache_read_per_1m'] > 0].copy()\n",
    "\n",
    "if not cache_models.empty:\n",
    "    print(\"\\nüîÑ Prompt Caching Savings:\\n\")\n",
    "    \n",
    "    # Calculate savings percentage\n",
    "    cache_models['Cache Discount'] = (\n",
    "        (cache_models['input_per_1m'] - cache_models['cache_read_per_1m']) / \n",
    "        cache_models['input_per_1m'] * 100\n",
    "    )\n",
    "    \n",
    "    display(cache_models[['input_per_1m', 'cache_read_per_1m', 'Cache Discount']].style.format({\n",
    "        'input_per_1m': '${:.2f}',\n",
    "        'cache_read_per_1m': '${:.2f}',\n",
    "        'Cache Discount': '{:.1f}%',\n",
    "    }).background_gradient(subset=['Cache Discount'], cmap='RdYlGn'))\n",
    "    \n",
    "    # Visualize cache savings\n",
    "    fig, ax = plt.subplots(figsize=(10, 6))\n",
    "    \n",
    "    cache_models['Cache Discount'].plot(kind='bar', ax=ax, color='green')\n",
    "    ax.set_title('üí∞ Cache Token Discount', fontsize=14, fontweight='bold')\n",
    "    ax.set_ylabel('Discount (%)', fontsize=12)\n",
    "    ax.set_xlabel('Model', fontsize=12)\n",
    "    ax.tick_params(axis='x', rotation=45)\n",
    "    ax.grid(axis='y', alpha=0.3)\n",
    "    \n",
    "    # Add percentage labels\n",
    "    for i, v in enumerate(cache_models['Cache Discount']):\n",
    "        ax.text(i, v + 1, f'{v:.1f}%', ha='center', fontweight='bold')\n",
    "    \n",
    "    plt.tight_layout()\n",
    "    plt.savefig('cache_savings.png', dpi=150, bbox_inches='tight')\n",
    "    plt.show()\n",
    "    \n",
    "    print(\"\\nüì∏ Saved: cache_savings.png\")\n",
    "    \n",
    "    print(\"\\nüí° Tip: Enable prompt caching to save ~90% on repeated context!\")\n",
    "else:\n",
    "    print(\"\\n‚ö†Ô∏è  No models with cache pricing found\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## üéØ Recommendations"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(\"\\n\" + \"=\"*70)\n",
    "print(\"üí° COST OPTIMIZATION RECOMMENDATIONS\")\n",
    "print(\"=\"*70)\n",
    "\n",
    "# Find cheapest models\n",
    "cheapest_input = pricing_df['input_per_1m'].idxmin()\n",
    "cheapest_output = pricing_df['output_per_1m'].idxmin()\n",
    "cheapest_total = pricing_df['total_per_1m'].idxmin()\n",
    "\n",
    "print(f\"\\nüèÜ Cheapest Models:\")\n",
    "print(f\"  üí¨ Input:  {cheapest_input} (${pricing_df.loc[cheapest_input, 'input_per_1m']:.2f}/1M)\")\n",
    "print(f\"  üí≠ Output: {cheapest_output} (${pricing_df.loc[cheapest_output, 'output_per_1m']:.2f}/1M)\")\n",
    "print(f\"  üí∏ Total:  {cheapest_total} (${pricing_df.loc[cheapest_total, 'total_per_1m']:.2f}/1M)\")\n",
    "\n",
    "# Monthly cost comparison\n",
    "cheapest_monthly = monthly_df['Monthly Cost (with cache)'].idxmin()\n",
    "most_expensive_monthly = monthly_df['Monthly Cost (with cache)'].idxmax()\n",
    "\n",
    "print(f\"\\nüìÖ Monthly Costs (100 tasks/day):\")\n",
    "print(f\"  üíö Cheapest:  {cheapest_monthly} (${monthly_df.loc[cheapest_monthly, 'Monthly Cost (with cache)']:.2f}/month)\")\n",
    "print(f\"  üí∏ Expensive: {most_expensive_monthly} (${monthly_df.loc[most_expensive_monthly, 'Monthly Cost (with cache)']:.2f}/month)\")\n",
    "\n",
    "cost_diff = monthly_df.loc[most_expensive_monthly, 'Monthly Cost (with cache)'] - monthly_df.loc[cheapest_monthly, 'Monthly Cost (with cache)']\n",
    "print(f\"  üí∞ Potential Savings: ${cost_diff:.2f}/month by choosing {cheapest_monthly}\")\n",
    "\n",
    "print(f\"\\nüîÑ Cache Optimization:\")\n",
    "if not cache_models.empty:\n",
    "    best_cache = cache_models['Cache Discount'].idxmax()\n",
    "    print(f\"  ü•á Best cache discount: {best_cache} ({cache_models.loc[best_cache, 'Cache Discount']:.1f}% off)\")\n",
    "    \n",
    "    total_monthly_savings = monthly_df['Monthly Savings'].sum()\n",
    "    print(f\"  üíé Total monthly savings with caching: ${total_monthly_savings:.2f}\")\n",
    "else:\n",
    "    print(f\"  ‚ö†Ô∏è  Cache pricing not available for tested models\")\n",
    "\n",
    "print(\"\\n\" + \"=\"*70)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
